## Design Principle
The ReComA library is designed around two basic design decisions:

1. Reasoning trace during the inference process is expressed in the form of [tree](/recoma/search/state.py#L112)

Each [node](/recoma/search/state.py#L10) in the tree has three basic fields:
   a. input_str: The input string to the target model that it must process
   b. target_model: The target model assigned to process this node
   c. is_open: Set to false once the target_model is done processing this node (e.g. the controller
   model for DecomP will stay open until the decomposer prompt generates [EOQ])

2. The reasoning process is modeled by the following algorithm:

```
  tree = []
  tree.root = Node(input=example.task, target_model=start_model)
  while tree has open nodes and max limit not reached:
    current_node = first open node in pre-order traversal # think "lowest" unprocessed node
    call current_node.target_model to process the current_node # process here can add new nodes or close the node, if done
```

The [Controller](/recoma/search/controller.py) implements the while loop described above. Each model
modifies the reasoning trace (called SearchState) by adding new open nodes or closing the node
assigned to them. Models are called with `__call__` function and they output reasoning trace(s) with
associated scores that are added to the heap in the [Best-First Search](/recoma/search/search.py).
When only one reasoning trace is generated by each model, the Best-First Search is equivalent to
Greedy Search.